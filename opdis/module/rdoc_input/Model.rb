#!/usr/bin/env ruby1.9
# :title: Opdis::DataModel
=begin rdoc
=Opdis Data Model
<i>Copyright 2010 Thoughtgang <http://www.thoughtgang.org></i>

= Opdis Data Model

== Summary

The Opdis data model provides a representation for Instruction and Opdis
objects that supports more sophisticated analyses than simple string
compares. The original strings produced by libopcodes are also made
available for 'raw' processing.

==Contact
Support:: community@thoughtgang.org
Project:: http://rubyforge.org/projects/opdis/ 
=end


module Opdis

=begin rdoc
A disassembled instruction.

The Instruction object contains information which may not be made available by
the decoder. The libopcodes disassembler generates a list of ASCII strings
which the decoder converts to Instruction objects. The generic decoder
(see InstructionDecoder) fills the <i>status</i>, <i>vma</i>, <i>size</i>, 
<i>bytes</i>, and <i>ascii</i> members.

Use the <i>status</i> member to determine how much information the decoder
was able to produce. DECODE_BASIC indicates that the generic decoder has
filled the fields mentioned above. DECODE MNEMONIC and DECODE_OPERANDS
indicate that the decoder has successfully identified the mnemonic and
the operands of the instruction, respectively; this means that the
<i>prefixes</i>, <i>mnemonic</i>, <i>operands</i>, <i>srce</i>, <i>dest</i>,
and <i>target</i> members have been filled, though the Operand objects in
<i>operands</i> will only have their <i>ascii</i> member filled. 
DECODE_MNEMONIC_FLAGS and DECODE_OPERAND_FLAGS indicate that instruction
and operand metadata have been filled.
=end
  class Instruction

=begin rdoc
The decoding status of an instruction. This will be DECODE_INVALID or any
combination of DECODE_BASIC, DECODE_MNEMONIC, DECODE_OPERANDS,
DECODE_MNEMONIC_FLAGS, and DECODE_OPERAND_FLAGS -- depending on how much
work the instruction decoder performed successfully.
=end
    attr_accessor :status

=begin rdoc
Virtual Memory Address. The in-memory address of the instruction.
=end
    attr_reader :vma

=begin rdoc
The size of the instruction in bytes.
=end
    attr_reader :size

=begin rdoc
An array containing the bytes of the instruction.
=end
    attr_reader :bytes

=begin rdoc
The target operand of a branch instruction, or <i>nil</i>.
=end
    attr_reader :target

=begin rdoc
The destination (write) operand of an instruction, or <i>nil</i>.
=end
    attr_reader :dest

=begin rdoc
The first source (read) operand of an instruction, or <i>nil</i>.
=end
    attr_reader :src

=begin rdoc
The category or high-level type of the instruction. This will be one of
CAT_CFLOW, CAT_STACK, CAT_LOADSTORE, CAT_TEST, CAT_MATH, CAT_BIT, CAT_IO,
CAT_TRAP, CAT_PRIV, CAT_NOP, or <i>nil</i> if the instruction category is
unknown.
=end
    attr_accessor :category

=begin rdoc
The category-specific flags for the instruction. This is generally used
to encode a specific instruction type, e.g. FLG_JMP for an unconditional
jump instruction, or FLG_POP for a stack pop instruction.
=end
    attr_reader :flags

=begin rdoc
The Instruction Set Architecture of the instruction. This is a subset of the
full CPU architecture ISA. 
    ISA_GEN, ISA_FPU, ISA_GPU, ISA_SIMD, ISA_VM
=end
    attr_accessor :isa

=begin rdoc
Array of instruction prefix strings.
=end
    attr_reader :prefixes

=begin rdoc
Array of Opdis::Operand objects..
=end
    attr_reader :operands

=begin rdoc
Instruction mnemonic string.
=end
    attr_accessor :mnemonic

=begin rdoc
Comment string generated by libopcodes.
=end
    attr_accessor :comment

=begin rdoc
Invalid instruction.
=end
    DECODE_INVALID='invalid'
=begin rdoc
Basic instruction decoding has been performed. This means that the <i>vma</i>,
<i>size</i>, <i>bytes</i>, and <i>ascii</i> members are valid.
=end
    DECODE_BASIC='basic'
=begin rdoc
Instruction mnemonic has been decoded. This means that the <i>prefixes</i> and
<i>mnemonic</i> members are valid.
=end
    DECODE_MNEMONIC='mnemonic'
=begin rdoc
Basic operand decoding has been performed. This means that the <i>src</i>,
<i>dest</i>, and <i>target</i> members are valid. The <i>operands</i> valid
has been filled with Operand objects whose <i>ascii</i> member is valid.
=end
    DECODE_OPERANDS='operands'
=begin rdoc
Instruction metadata has been decoded. This means that the Instruction
<i>isa</i>, <i>category</i>, and <i>flags</i> members are valid.
=end
    DECODE_MNEMONIC_FLAGS='mnemonic flags'
=begin rdoc
Operand metadata has been decoded. This means that the <i>operands</i> field
is filled with objects derived from Operand, whose members are all valid.
=end
    DECODE_OPERAND_FLAGS='operand flags'

=begin rdoc
General-purpose instruction set. The default ISA for all instructions.
=end
    ISA_GEN='general'
=begin rdoc
Floating-point instruction set.
=end
    ISA_FPU='fpu'
=begin rdoc
Graphics card instruction set.
=end
    ISA_GPU='gpu'
=begin rdoc
SIMD (single instruction, multiple data) instruction set. Examples include
MMX, SSE, SSE2, SSE3, Altivec, and 3DNow! instructions.
=end
    ISA_SIMD='simd'
=begin rdoc
Virtual Machine or virtualization (hypervisor) extensions.
=end
    ISA_VM='vm'
    
=begin rdoc
Unrecognized instruction.
=end
    CAT_UNKNOWN='unknown'
=begin rdoc
Control flow (jump, call, return) instruction.
=end
    CAT_CFLOW='control-flow'
=begin rdoc
Stack manipulation (push, pop) instruction.
=end
    CAT_STACK='stack'
=begin rdoc
Load/store (move) instruction.
=end
    CAT_LOADSTORE='load/store'
=begin rdoc
Test or compare instruction.
=end
    CAT_TEST='test'
=begin rdoc
Mathematical (add, sub, mul, etc) instruction.
=end
    CAT_MATH='mathematic'
=begin rdoc
Logical (and, or, xor, not, etc) instruction.
=end
    CAT_BIT='bitwise'
=begin rdoc
Input/output (i.e. port read/write) instruction.
=end
    CAT_IO='i/o'
=begin rdoc
Trap or interrupt instruction.
=end
    CAT_TRAP='trap'
=begin rdoc
Privileged (ring0) or system management instruction.
=end
    CAT_PRIV='privileged'
=begin rdoc
No-operation instruction.
=end
    CAT_NOP='no-op'

=begin rdoc
Call a procedure.
=end
    FLG_CALL='call'
=begin rdoc
Conditionally call a procedure.
=end
    FLG_CALLCC='conditional call'
=begin rdoc
Jump to an address.
=end
    FLG_JMP='jump'
=begin rdoc
Conditionally jump to an address.
=end
    FLG_JMPCC='conditional jump'
=begin rdoc
Return from a procedure.
=end
    FLG_RET='return'
=begin rdoc
Push onto the stack.
=end
    FLG_PUSH='push'
=begin rdoc
Pop from the stack.
=end
    FLG_POP='pop'
=begin rdoc
Enter a stack frame.
=end
    FLG_FRAME='enter frame'
=begin rdoc
Leave a stack frame.
=end
    FLG_UNFRAME='leave frame'
=begin rdoc
Logical AND operation.
=end
    FLG_AND='bitwise and'
=begin rdoc
Lofical OR operation.
=end
    FLG_OR='bitwise or'
=begin rdoc
Logical XOR operation.
=end
    FLG_XOR='bitwise xor'
=begin rdoc
Logical NOT operation.
=end
    FLG_NOT='bitwise not'
=begin rdoc
Logical (no carry) shift left.
=end
    FLG_LSL='logical shift left'
=begin rdoc
Logical (no carry) shift right.
=end
    FLG_LSR='logical shift right'
=begin rdoc
Arithmetic (with carry) shift left.
=end
    FLG_ASL='arithmetic shift left'
=begin rdoc
Arithmetic (with carry) shift right.
=end
    FLG_ASR='arithmetic shift right'
=begin rdoc
Logical (no carry) rotate left.
=end
    FLG_ROL='rotate left'
=begin rdoc
Logical (no carry) rotate right.
=end
    FLG_ROR='rotate right'
=begin rdoc
Arithmetic (with carry) rotate left.
=end
    FLG_RCL='rotate carry left'
=begin rdoc
Arithmetic (with carry) rotate right.
=end
    FLG_RCR='rotate carry right'
=begin rdoc
Read from I/O port.
=end
    FLG_IN='input from port'
=begin rdoc
Write to I/O port.
=end
    FLG_OUT='output to port'

=begin rdoc
Returns true if the instruction is a branch (is a CALL, CALLCC, JMP, or
JMPCC). This is only reliable if <i>status</i> includes DECODE_MNEMONIC_FLAGS.
=end
    def branch?
    end

=begin rdoc
Returns true if execution falls through to the next instruction. This is true
in all cases except JMP and RET. This is only reliable if <i>status</i> 
includes DECODE_MNEMONIC_FLAGS.
=end
    def fallthrough?
    end

=begin rdoc
Returns the <i>ascii</i> field if the instruction.
=end
    def to_s
    end
  end

=begin rdoc
An instruction operand. A properly-decoded instruction will have Operand
subclasses in its <i>operands</i> array; the Operand base class is used only
when the operand strings have been identified by the decoder but not
processed.
=end
  class Operand

=begin rdoc
Metadata containing additional information about the operand
=end
    attr_accessor :flags

=begin rdoc
The size in bytes of the data referenced by the instruction, or <i>nil</i> if
not known.
=end
    attr_accessor :data_size

=begin rdoc
The string for the operand returned by libopcodes.
=end
    attr_accessor :ascii

=begin rdoc
Operand is read by instruction.
=end
    FLG_R='r'
=begin rdoc
Operand is written to by instruction.
=end
    FLG_W='w'
=begin rdoc
Operand is executed (jumped to) by instruction.
=end
    FLG_X='x'
=begin rdoc
=end
    FLG_SIGNED='signed'
=begin rdoc
=end
    FLG_ADDR='address'
=begin rdoc
=end
    FLG_INDIRECT='indirect address'

=begin rdoc
Returns the <i>ascii</i> field.
=end
    def to_s
    end
  end

=begin rdoc
A numeric value explicitly encoded in the bytes of the instruction.
=end
  class ImmediateOperand < Operand

=begin rdoc
The immediate value, interpreted as signed or unsigned based on whether
Operand#flags includes FLG_SIGNED.
=end
    attr_accessor :value

=begin rdoc
The immediate value interpreted as a signed integer.
=end
    attr_accessor :signed

=begin rdoc
The immediate value interpreted as an unsigned integer.
=end
    attr_accessor :unsigned

=begin rdoc
The immediate value interpreted as a VMA.
=end
    attr_accessor :vma
  end

=begin rdoc
An address expression such as an Intel Effective Address. This generally
takes the form of

base + (index * scale) + disp

where <b>base</b> and <b>index</b> are registers, <b>scale</b> is a power of
two, <b>disp</b> is an immediate value, and <b>*</b> is a "shift operation"
(generally arithmetic shift left).
=end
  class AddressExpressionOperand < Operand

=begin rdoc
The shift algorithm used by the expression. This is one of SHIFT_ASL,
SHIFT_LSL, SHIFT_LSR, SHIFT_ROR, or SHIFT_RRX. The default is SHIFT_ASL;
the other algorithms apply to the ARM architecture.
=end
    attr_accessor :shift

=begin rdoc
The scale factor of the expression. This must be a power of two; the default
scale value is <b>1</b>.
=end
    attr_accessor :scale

=begin rdoc
A Register object for the <b>index</b> value of the expression, or <i>nil</i> if
the expression does not use an index value.
=end
    attr_accessor :index

=begin rdoc
A Register object for the <b>base</b> value of the expression, or <i>nil</i> if
the expression does not use an base value.
=end
    attr_accessor :base

=begin rdoc
A numeric value or an AbsoluteAddress object for the displacement of the 
expression, or <i>nil</i> if the expression does not use a displacement.
=end
    attr_accessor :displacement

=begin rdoc
Logical (no carry) shift left.
=end
    SHIFT_LSL='lsl'
=begin rdoc
Logical (no carry) shift right.
=end
    SHIFT_LSR='lsr'
=begin rdoc
Arithmetic (carry) shift left.
=end
    SHIFT_ASL='asl'
=begin rdoc
Logical (no carry) rotate right.
=end
    SHIFT_ROR='ror'
=begin rdoc
=end
    SHIFT_RRX='rrx'
  end

=begin rdoc
A segmented address consisting of a base (segment) register and a displacement
or offset. In Intel notation, these take the form <b>segment:offset</b>.
=end
  class AbsoluteAddress

=begin rdoc
A Register object for the segment or base of the absolute address.
=end
    attr_accessor :segment

=begin rdoc
An immediate value for the offset or displacement of the absolute address.
=end
    attr_accessor :offset
  end

=begin rdoc
An AbsoluteAddress operand.

See AbsoluteAddress class.
=end
  class AbsoluteAddressOperand < Operand

    attr_accessor :segment, :offset

  end

=begin rdoc
A CPU register.
=end
  class Register

=begin rdoc
A numeric ID for the register. Registers with the same ID but different names
are aliases of each other.
=end
    attr_reader :id

=begin rdoc
The size of the register in bytes.
=end
    attr_reader :size

=begin rdoc
The name or mnemonic for the register.
=end
    attr_reader :name

=begin rdoc
Metadata describing the purpose or general use of the register.
=end
    attr_accessor :purpose

=begin rdoc
A general-purpose register.
=end
    FLG_GEN='general purpose'
=begin rdoc
A floating-point register.
=end
    FLG_FPU='fpu'
=begin rdoc
A register on the graphics card.
=end
    FLG_GPU='gpu'
=begin rdoc
An SIMD register.
=end
    FLG_SIMD='simd'
=begin rdoc
A system register for task management.
=end
    FLG_TASK='task mgt'
=begin rdoc
A system register for memory management.
=end
    FLG_MEM='memory mgt'
=begin rdoc
A system register providing debugger support.
=end
    FLG_DBG='debug'
=begin rdoc
The program counter or instruction pointer.
=end
    FLG_PC='pc'
=begin rdoc
The flags or condition code register.
=end
    FLG_FLAGS='flags'
=begin rdoc
The stack pointer.
=end
    FLG_STACK='stack'
=begin rdoc
The frame pointer.
=end
    FLG_FRAME='stack frame'
=begin rdoc
A memory segment register.
=end
    FLG_SEG='segment'
=begin rdoc
The (virtual) zero register.
=end
    FLG_Z='zero'
=begin rdoc
A register used for incoming arguments inside a procedure.
=end
    FLG_IN='args in'
=begin rdoc
A register used for outgoing arguments in a procedure call.
=end
    FLG_OUT='args out'
=begin rdoc
A register used for local variables inside a procedure.
=end
    FLG_LOCALS='locals'
=begin rdoc
A register used for a return value from a procedure call.
=end
    FLG_RET='return'
  end

=begin rdoc
A register operand.

See Register class.
=end
  class RegisterOperand < Operand

    attr_reader :id, :size,:name
    attr_accessor :purpose

    FLG_GEN='general purpose'
    FLG_FPU='fpu'
    FLG_GPU='gpu'
    FLG_SIMD='simd'
    FLG_TASK='task mgt'
    FLG_MEM='memory mgt'
    FLG_DBG='debug'
    FLG_PC='pc'
    FLG_FLAGS='flags'
    FLG_STACK='stack'
    FLG_FRAME='stack frame'
    FLG_SEG='segment'
    FLG_Z='zero'
    FLG_IN='args in'
    FLG_OUT='args out'
    FLG_LOCALS='locals'
    FLG_RET='return'
  end

end
