#!/usr/bin/env ruby1.9
# :title: Opdis::DataModel
=begin rdoc
=Opdis Data Model
<i>Copyright 2010 Thoughtgang <http://www.thoughtgang.org></i>

= Opdis Data Model

== Summary

==Example

==Contact
Support:: community@thoughtgang.org
Project:: http://rubyforge.org/projects/opdis/ 
=end


module Opdis

=begin rdoc
=end
  class Instruction

=begin rdoc
The decoding status of an instruction. This will be DECODE_INVALID or any
combination of DECODE_BASIC, DECODE_MNEMONIC, DECODE_OPERANDS,
DECODE_MNEMONIC_FLAGS, and DECODE_OPERAND_FLAGS -- depending on how much
work the instruction decoder performed successfully.
=end
    attr_accessor :status

=begin rdoc
Virtual Memory Address. The in-memory address of the instruction.
=end
    attr_reader :vma

=begin rdoc
The size of the instruction in bytes.
=end
    attr_reader :size

=begin rdoc
An array containing the bytes of the instruction.
=end
    attr_reader :bytes

=begin rdoc
The target operand of a branch instruction, or <i>nil</i>.
=end
    attr_reader :target

=begin rdoc
The destination (write) operand of an instruction, or <i>nil</i>.
=end
    attr_reader :dest

=begin rdoc
The first source (read) operand of an instruction, or <i>nil</i>.
=end
    attr_reader :src

=begin rdoc
The category or high-level type of the instruction. This will be one of
CAT_CFLOW, CAT_STACK, CAT_LOADSTORE, CAT_TEST, CAT_MATH, CAT_BIT, CAT_IO,
CAT_TRAP, CAT_PRIV, CAT_NOP, or <i>nil</i> if the instruction category is
unknown.
=end
    attr_accessor :category

=begin rdoc
The category-specific flags for the instruction. This is generally used
to encode a specific instruction type, e.g. FLG_JMP for an unconditional
jump instruction, or FLG_POP for a stack pop instruction.
=end
    attr_reader :flags

=begin rdoc
The Instruction Set Architecture of the instruction. This is a subset of the
full CPU architecture ISA. 
    ISA_GEN, ISA_FPU, ISA_GPU, ISA_SIMD, ISA_VM
=end
    attr_accessor :isa

=begin rdoc
Array of instruction prefix strings.
=end
    attr_reader :prefixes

=begin rdoc
Array of Opdis::Operand objects..
=end
    attr_reader :operands

=begin rdoc
Instruction mnemonic string.
=end
    attr_accessor :mnemonic

=begin rdoc
Comment string generated by libopcodes.
=end
    attr_accessor :comment

=begin rdoc
Invalid instruction.
=end
    DECODE_INVALID='invalid'
=begin rdoc
Basic instruction decoding (vma, bytes, ascii) has been performed.
=end
    DECODE_BASIC='basic'
=begin rdoc
Instruction mnemonic has been decoded.
=end
    DECODE_MNEMONIC='mnemonic'
=begin rdoc
Basic operand decoding has been performed.
=end
    DECODE_OPERANDS='operands'
=begin rdoc
Instruction metadata (category, flags) has been decoded.
=end
    DECODE_MNEMONIC_FLAGS='mnemonic flags'
=begin rdoc
Operand metadata (type, flags) has been decoded.
=end
    DECODE_OPERAND_FLAGS='operand flags'

=begin rdoc
General instruction set.
=end
    ISA_GEN='general'
=begin rdoc
Floating-point instruction set.
=end
    ISA_FPU='fpu'
=begin rdoc
Graphics card instruction set.
=end
    ISA_GPU='gpu'
=begin rdoc
SIMD (single instruction, multiple data) instruction set.
=end
    ISA_SIMD='simd'
=begin rdoc
Virtual Machine or virtualization (hypervisor) extension.
=end
    ISA_VM='vm'
    
=begin rdoc
Uknrecognized instruction.
=end
    CAT_UNKNOWN='unknown'
=begin rdoc
Control flow (jump, call, return) instruction.
=end
    CAT_CFLOW='control-flow'
=begin rdoc
Stack manipulation (push, pop) instruction.
=end
    CAT_STACK='stack'
=begin rdoc
Load/store (move) instruction.
=end
    CAT_LOADSTORE='load/store'
=begin rdoc
Test or compare instruction.
=end
    CAT_TEST='test'
=begin rdoc
Mathematical (add, sub, mul, etc) instruction.
=end
    CAT_MATH='mathematic'
=begin rdoc
Logical (and, or, xor, not, etc) instruction.
=end
    CAT_BIT='bitwise'
=begin rdoc
Input/output (i.e. port read/write) instruction.
=end
    CAT_IO='i/o'
=begin rdoc
Trap or interrupt instruction.
=end
    CAT_TRAP='trap'
=begin rdoc
Privileged (ring0) or system management instruction.
=end
    CAT_PRIV='privileged'
=begin rdoc
No-operation instruction.
=end
    CAT_NOP='no-op'

=begin rdoc
Call a procedure.
=end
    FLG_CALL='call'
=begin rdoc
Conditionally call a procedure.
=end
    FLG_CALLCC='conditional call'
=begin rdoc
Jump to an address.
=end
    FLG_JMP='jump'
=begin rdoc
Conditionally jump to an address.
=end
    FLG_JMPCC='conditional jump'
=begin rdoc
Return from a procedure.
=end
    FLG_RET='return'
=begin rdoc
Push onto the stack.
=end
    FLG_PUSH='push'
=begin rdoc
Pop from the stack.
=end
    FLG_POP='pop'
=begin rdoc
Enter a stack frame.
=end
    FLG_FRAME='enter frame'
=begin rdoc
Leave a stack frame.
=end
    FLG_UNFRAME='leave frame'
=begin rdoc
Logical AND operation.
=end
    FLG_AND='bitwise and'
=begin rdoc
Lofical OR operation.
=end
    FLG_OR='bitwise or'
=begin rdoc
Logical XOR operation.
=end
    FLG_XOR='bitwise xor'
=begin rdoc
Logical NOT operation.
=end
    FLG_NOT='bitwise not'
=begin rdoc
Logical (no carry) shift left.
=end
    FLG_LSL='logical shift left'
=begin rdoc
Logical (no carry) shift right.
=end
    FLG_LSR='logical shift right'
=begin rdoc
Arithmetic (with carry) shift left.
=end
    FLG_ASL='arithmetic shift left'
=begin rdoc
Arithmetic (with carry) shift right.
=end
    FLG_ASR='arithmetic shift right'
=begin rdoc
Logical (no carry) rotate left.
=end
    FLG_ROL='rotate left'
=begin rdoc
Logical (no carry) rotate right.
=end
    FLG_ROR='rotate right'
=begin rdoc
Arithmetic (with carry) rotate left.
=end
    FLG_RCL='rotate carry left'
=begin rdoc
Arithmetic (with carry) rotate right.
=end
    FLG_RCR='rotate carry right'
=begin rdoc
Read from I/O port.
=end
    FLG_IN='input from port'
=begin rdoc
Write to I/O port.
=end
    FLG_OUT='output to port'

=begin rdoc
=end
    def initialize(args)
    end

=begin rdoc
=end
    def branch?
    end

=begin rdoc
=end
    def fallthrough?
    end

=begin rdoc
=end
    def to_s
    end
  end

=begin rdoc
=end
  class Operand

=begin rdoc
=end
    attr_accessor :flags

=begin rdoc
=end
    attr_accessor :data_size

=begin rdoc
Operand is read by instruction.
=end
    FLG_R='r'
=begin rdoc
Operand is written to by instruction.
=end
    FLG_W='w'
=begin rdoc
Operand is executed (jumped to) by instruction.
=end
    FLG_X='x'
=begin rdoc
=end
    FLG_SIGNED='signed'
=begin rdoc
=end
    FLG_ADDR='address'
=begin rdoc
=end
    FLG_INDIRECT='indirect address'

=begin rdoc
=end
    def to_s
    end
  end

=begin rdoc
=end
  class ImmediateOperand < Operand

=begin rdoc
=end
    attr_accessor :value

=begin rdoc
=end
    attr_accessor :signed

=begin rdoc
=end
    attr_accessor :unsigned

=begin rdoc
=end
    attr_accessor :vma
  end

=begin rdoc
=end
  class AddressExpressionOperand < Operand

=begin rdoc
=end
    attr_accessor :shift

=begin rdoc
=end
    attr_accessor :scale

=begin rdoc
=end
    attr_accessor :index

=begin rdoc
=end
    attr_accessor :base

=begin rdoc
=end
    attr_accessor :displacement

=begin rdoc
=end
    SHIFT_LSL='lsl'
=begin rdoc
=end
    SHIFT_LSR='lsr'
=begin rdoc
=end
    SHIFT_ASL='asl'
=begin rdoc
=end
    SHIFT_ROR='ror'
=begin rdoc
=end
    SHIFT_RRX='rrx'
  end

=begin rdoc
=end
  class AbsoluteAddress

=begin rdoc
=end
    attr_accessor :segment

=begin rdoc
=end
    attr_accessor :offset
  end

=begin rdoc
An absolute address operand.

See AbsoluteAddress class.
=end
  class AbsoluteAddressOperand < Operand

    attr_accessor :segment

    attr_accessor :offset
  end

=begin rdoc
=end
  class Register

=begin rdoc
=end
    attr_reader :id

=begin rdoc
=end
    attr_reader :size

=begin rdoc
=end
    attr_reader :name

=begin rdoc
=end
    attr_accessor :flags

=begin rdoc
=end
    FLG_GEN='general purpose'
=begin rdoc
=end
    FLG_FPU='fpu'
=begin rdoc
=end
    FLG_GPU='gpu'
=begin rdoc
=end
    FLG_SIMD='simd'
=begin rdoc
=end
    FLG_TASK='task mgt'
=begin rdoc
=end
    FLG_MEM='memory mgt'
=begin rdoc
=end
    FLG_DBG='debug'
=begin rdoc
=end
    FLG_PC='pc'
=begin rdoc
=end
    FLG_FLAGS='flags'
=begin rdoc
=end
    FLG_STACK='stack'
=begin rdoc
=end
    FLG_FRAME='stack frame'
=begin rdoc
=end
    FLG_SEG='segment'
=begin rdoc
=end
    FLG_Z='zero'
=begin rdoc
=end
    FLG_IN='args in'
=begin rdoc
=end
    FLG_OUT='args out'
=begin rdoc
=end
    FLG_LOCALS='locals'
=begin rdoc
=end
    FLG_RET='return'
  end

=begin rdoc
A register operand.

See Register class.
=end
  class RegisterOperand < Operand

    attr_reader :id

    attr_reader :size

    attr_reader :name

    attr_accessor :flags

    FLG_GEN='general purpose'
    FLG_FPU='fpu'
    FLG_GPU='gpu'
    FLG_SIMD='simd'
    FLG_TASK='task mgt'
    FLG_MEM='memory mgt'
    FLG_DBG='debug'
    FLG_PC='pc'
    FLG_FLAGS='flags'
    FLG_STACK='stack'
    FLG_FRAME='stack frame'
    FLG_SEG='segment'
    FLG_Z='zero'
    FLG_IN='args in'
    FLG_OUT='args out'
    FLG_LOCALS='locals'
    FLG_RET='return'
  end

end
